(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{483:function(a,v,_){"use strict";_.r(v);var t=_(2),s=Object(t.a)({},(function(){var a=this,v=a._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[v("h1",{attrs:{id:"第一章"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第一章"}},[a._v("#")]),a._v(" 第一章")]),a._v(" "),v("h3",{attrs:{id:"概述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#概述"}},[a._v("#")]),a._v(" 概述")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("操作系统是一个软件\n\n作为管理者\n操作系统的功能和要求\n          功能：处理机管理 存储器（内存）管理 文件管理 设备管理\n           要求： 高效 安全\n\n向用户提供服务\n        需要提供：命令接口 程序接口 图形接口（GUI）\n\n命令接口：联机和脱机 就是交互式 一个是批处理（.bat）\n        程序接口：win中的（dll）-- 一组系统调用\n        GUI：就是我们可以通过图像和系统交互\n\n对硬件拓展\n\n特征（前面两个为基本）\n    并发：并非并行，这个并发其实是宏观上，在很细分其实是有一定的时间交替的\n    共享\n    虚拟\n    异步\n")])])]),v("h3",{attrs:{id:"发展过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#发展过程"}},[a._v("#")]),a._v(" 发展过程")]),a._v(" "),v("p",[a._v("手工（纸带打孔）\n批处理（单道、多道（中断技术）批处理系统）\n分时间操作系统（时间片）\n实时操作系统（可以优先响应紧急的任务，规定严格的时间，有软硬实时的区分）\n网络 分布式\n多道（中断技术）批处理系统--已经有并发，操作系统同时诞生")]),a._v(" "),v("p",[a._v("操作系统的运行机制和系统的结构\n运行机制：\n-- 指令和代码的区别：机器语言指令，一般的高级语言最后都会变成机器语言指令即2进制\n-- 指令也是有等级，特权和非特权，操作内存之类的指令就是特权\n-- 处理器的状态可以执行不同等级的指令， 用户态（目态）-- 只能非特权 核心态（管态）--两个都可以\n-- 这个状态是由cpu的内部寄出器决定的\n-- 相应的就有两种程序，应用程序和内核程序对应了两种状态")]),a._v(" "),v("h3",{attrs:{id:"内核"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#内核"}},[a._v("#")]),a._v(" 内核")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("最接近硬件\n    包含：时钟管理 中断管理 原语（驱动 cpu）系统资源的管理（有的os内核不包含）--进程管理 存储器管理 设备管理\n    分为：大内核和微内核 （这是由于内核的架构而分的，就是设计时候的功能）\n        大内核：一般代码多\n        微内核：一般需要频繁切换cpu的状态，效率会低，方便维护\n\n中断和异常：\n        中断机制：\n")])])]),v("h1",{attrs:{id:"第二章"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#第二章"}},[a._v("#")]),a._v(" 第二章")]),a._v(" "),v("h2",{attrs:{id:"进程于线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程于线程"}},[a._v("#")]),a._v(" 进程于线程")]),a._v(" "),v("h3",{attrs:{id:"进程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程"}},[a._v("#")]),a._v(" 进程")]),a._v(" "),v("p",[a._v("是在多道技术的发展 推动了进程")]),a._v(" "),v("p",[a._v("PCB 数据段 程序段 组成了进程实体 （静态）")]),a._v(" "),v("p",[a._v("PCB就是进程存在的唯一标识")]),a._v(" "),v("p",[a._v("进程（动态）是系统进行资源调度的单位")]),a._v(" "),v("h5",{attrs:{id:"pcb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#pcb"}},[a._v("#")]),a._v(" PCB")]),a._v(" "),v("p",[a._v("进程信息描述：进程标识符PID 用户标识UID")]),a._v(" "),v("p",[a._v("控制和信息： 优先级")]),a._v(" "),v("p",[a._v("资源分配清单：指针 外设")]),a._v(" "),v("p",[a._v("处理机相关信息：寄存器（保护数据）")]),a._v(" "),v("h5",{attrs:{id:"组织"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#组织"}},[a._v("#")]),a._v(" 组织")]),a._v(" "),v("p",[a._v("链接：将PCB分为多个队列，并分配指针")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("执行指针 就绪队列指针 阻塞队列指针 指向对应状态的PCB\n")])])]),v("p",[a._v("索引：将多个PCB分配并建立索引表")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("执行指针 就绪队列指针 阻塞队列指针 指向索引表，索引表中会对应到PCB\n")])])]),v("h5",{attrs:{id:"特征"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#特征"}},[a._v("#")]),a._v(" 特征")]),a._v(" "),v("p",[a._v("动态 并发 独立 异步 结构")]),a._v(" "),v("h3",{attrs:{id:"进程的状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程的状态转换"}},[a._v("#")]),a._v(" 进程的状态转换")]),a._v(" "),v("h6",{attrs:{id:"状态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[a._v("#")]),a._v(" 状态")]),a._v(" "),v("p",[a._v("三种基本状态")]),a._v(" "),v("ol",[v("li",[a._v("运行：占用cpu，看多少核，就可以同时有多少进程")]),a._v(" "),v("li",[a._v("就绪：具有运行状态，拥有资源，但cpu没有空位给它")]),a._v(" "),v("li",[a._v("阻塞：等待某个事件的发生而没有运作，很像中断")]),a._v(" "),v("li",[a._v("创建（情况）：给进程PID UID之类")]),a._v(" "),v("li",[a._v("终止（情况）：回收内存的空间，PCB销毁")])]),a._v(" "),v("h6",{attrs:{id:"状态转换"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#状态转换"}},[a._v("#")]),a._v(" 状态转换")]),a._v(" "),v("p",[v("img",{attrs:{src:"image/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/1661500941952.png",alt:"1661500941952"}})]),a._v(" "),v("h5",{attrs:{id:"进程控制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程控制"}},[a._v("#")]),a._v(" 进程控制")]),a._v(" "),v("p",[a._v("进程")]),a._v(" "),v("p",[a._v("原语：开关中断信号  运行在核心态下")]),a._v(" "),v("h3",{attrs:{id:"进程通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#进程通信"}},[a._v("#")]),a._v(" 进程通信")]),a._v(" "),v("p",[a._v("实现的方式：共享存储 消息传递 管道通信")]),a._v(" "),v("h5",{attrs:{id:"共享存储"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#共享存储"}},[a._v("#")]),a._v(" 共享存储")]),a._v(" "),v("p",[a._v("给一个共享的内存空间，让两个进程进行消息或者数据交互，但这需要两个互斥（就是两者只有一者可以访问这个空间）")]),a._v(" "),v("p",[a._v("有两种方式：数据结构和存储区    前者比较低级有限制")]),a._v(" "),v("h5",{attrs:{id:"管道通信"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#管道通信"}},[a._v("#")]),a._v(" 管道通信")]),a._v(" "),v("p",[a._v("固定大小的缓存区域，采用半双工通信--即在一个时间段内只能由一个进程向另外一个进程通信")]),a._v(" "),v("p",[a._v("对于管道的访问也是互斥，就是读写是分离")]),a._v(" "),v("h5",{attrs:{id:"消息传递"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#消息传递"}},[a._v("#")]),a._v(" 消息传递")]),a._v(" "),v("p",[a._v("交换的是格式化的消息")]),a._v(" "),v("p",[a._v("消息： 消息头（身份信息，像写信的信封一样） 消息体")]),a._v(" "),v("p",[a._v("方式： 直接和间接（放到一个固定的地方，就像信箱）")]),a._v(" "),v("h3",{attrs:{id:"线程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#线程"}},[a._v("#")]),a._v(" 线程")]),a._v(" "),v("p",[a._v("进程需要同时处理很多事情，但是进程一般串行的，为了提高并发的程度，引入线程")]),a._v(" "),v("p",[a._v("一个进程中分为多个线程，可以并发的执行，线程是最小的执行流单位。")]),a._v(" "),v("p",[a._v("线程只是调度的基本单位，资源的分配还是由进程进行。")]),a._v(" "),v("p",[a._v("组成：ID和TCB")]),a._v(" "),v("p",[a._v("基本状态和进程类似")]),a._v(" "),v("h5",{attrs:{id:"实现方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现方式"}},[a._v("#")]),a._v(" 实现方式")]),a._v(" "),v("p",[a._v("用户级线程：是在用户态下进行")]),a._v(" "),v("p",[a._v("内核级线程： 由操作系统的内核管理  ，这个才是处理机分配的单位")]),a._v(" "),v("h5",{attrs:{id:"多线程模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程模型"}},[a._v("#")]),a._v(" 多线程模型")]),a._v(" "),v("p",[a._v("多对一：")]),a._v(" "),v("p",[a._v("一对一：")]),a._v(" "),v("p",[a._v("多对多：")]),a._v(" "),v("h2",{attrs:{id:"调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度"}},[a._v("#")]),a._v(" 调度")]),a._v(" "),v("h3",{attrs:{id:"处理机调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#处理机调度"}},[a._v("#")]),a._v(" 处理机调度")]),a._v(" "),v("p",[a._v("就是分配，排队")]),a._v(" "),v("h5",{attrs:{id:"高级调度-作业调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#高级调度-作业调度"}},[a._v("#")]),a._v(" 高级调度(作业调度)")]),a._v(" "),v("p",[a._v("面向作业")]),a._v(" "),v("p",[a._v("就是调入内存的顺序   外存 => 内存")]),a._v(" "),v("h5",{attrs:{id:"中级调度-内存调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#中级调度-内存调度"}},[a._v("#")]),a._v(" 中级调度(内存调度)")]),a._v(" "),v("p",[a._v("面向进程")]),a._v(" "),v("p",[a._v("外存 => 内存")]),a._v(" "),v("p",[a._v("进程被调出外存会到挂起状态，会有一个队列，是把那个挂起状态调入和调出内存")]),a._v(" "),v("p",[a._v("挂起有两种就是就绪挂起和阻塞挂起。")]),a._v(" "),v("p",[a._v("挂起是放在进程映像里，而不在内存")]),a._v(" "),v("h5",{attrs:{id:"低级调度-进程调度"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#低级调度-进程调度"}},[a._v("#")]),a._v(" 低级调度(进程调度)")]),a._v(" "),v("p",[a._v("最基本的调度，就是把一个进程调入cpu执行")]),a._v(" "),v("p",[a._v("内存 => CPU")]),a._v(" "),v("h5",{attrs:{id:"时机"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#时机"}},[a._v("#")]),a._v(" 时机")]),a._v(" "),v("p",[a._v("当前运行的进程主动或是被动放弃处理机，就会发生进程调度")]),a._v(" "),v("p",[a._v("不可进程调度时：")]),a._v(" "),v("ol",[v("li",[a._v("处理中断的时候")]),a._v(" "),v("li",[a._v("进程在内核的临界区 内核临界区--就是访问内核一些数据结构（例如进程队列）")]),a._v(" "),v("li",[a._v("进行原子操作的过程（原语）")])]),a._v(" "),v("h5",{attrs:{id:"切换和过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#切换和过程"}},[a._v("#")]),a._v(" 切换和过程")]),a._v(" "),v("ol",[v("li",[a._v("对原运行的进程进行数据保护")]),a._v(" "),v("li",[a._v("对新进来的进程进行数据恢复")])]),a._v(" "),v("h5",{attrs:{id:"方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#方式"}},[a._v("#")]),a._v(" 方式")]),a._v(" "),v("p",[a._v("非剥夺（非抢占）：只允许进程主动放弃")]),a._v(" "),v("p",[a._v("剥夺（抢占）：允许进程被动放弃处理机 -- 分时 实时")]),a._v(" "),v("h3",{attrs:{id:"调度算法的评估指标"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度算法的评估指标"}},[a._v("#")]),a._v(" 调度算法的评估指标")]),a._v(" "),v("h5",{attrs:{id:"cpu利用率"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cpu利用率"}},[a._v("#")]),a._v(" CPU利用率")]),a._v(" "),v("p",[a._v("就是cpu处于忙碌的时间占总时间的比例")]),a._v(" "),v("p",[a._v("甘特图")]),a._v(" "),v("h5",{attrs:{id:"系统吞吐量"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#系统吞吐量"}},[a._v("#")]),a._v(" 系统吞吐量")]),a._v(" "),v("p",[a._v("单位时间内完成的作业")]),a._v(" "),v("h5",{attrs:{id:"周转时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#周转时间"}},[a._v("#")]),a._v(" 周转时间")]),a._v(" "),v("p",[a._v("作业提交给系统到作业完成的时间")]),a._v(" "),v("p",[a._v("有平均和带权")]),a._v(" "),v("h5",{attrs:{id:"等待时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#等待时间"}},[a._v("#")]),a._v(" 等待时间")]),a._v(" "),v("p",[a._v("等待被服务的时间")]),a._v(" "),v("p",[a._v("就是在外存中队列等待作业调度，还有进程内在系统内部，在等待IO设备实现的时间不算等待时间")]),a._v(" "),v("h5",{attrs:{id:"响应时间"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#响应时间"}},[a._v("#")]),a._v(" 响应时间")]),a._v(" "),v("p",[a._v("用户提交到被响应的时间")]),a._v(" "),v("h3",{attrs:{id:"调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#调度算法"}},[a._v("#")]),a._v(" 调度算法")]),a._v(" "),v("h4",{attrs:{id:"用于早期批处理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#用于早期批处理"}},[a._v("#")]),a._v(" 用于早期批处理")]),a._v(" "),v("h5",{attrs:{id:"fcfs-先来先服务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#fcfs-先来先服务"}},[a._v("#")]),a._v(" FCFS（先来先服务）")]),a._v(" "),v("p",[a._v("先进入队列的作业/进程先进入就绪队列先进行行服务 -- 非抢占式")]),a._v(" "),v("p",[a._v("优缺点：")]),a._v(" "),v("ol",[v("li",[a._v("公平简单")]),a._v(" "),v("li",[a._v("对于长作业/进程后的短作业/进程会不利，对短作业不利")])]),a._v(" "),v("p",[a._v("不会导致饥饿，就是都会进行服务")]),a._v(" "),v("h5",{attrs:{id:"sjf-短作业优先"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sjf-短作业优先"}},[a._v("#")]),a._v(" SJF（短作业优先）")]),a._v(" "),v("p",[a._v("最求平均等待时间最短，是要求当前到达的服务时间最短的优先被服务，可以用在进程（SPF）和作业")]),a._v(" "),v("p",[a._v("一般非抢占式，可以设计为抢占式（SRTN）-- 每当就绪队列变化时，要计算一下剩余的时间谁短就运行谁")]),a._v(" "),v("p",[a._v("优缺点：")]),a._v(" "),v("ol",[v("li",[a._v("可以获的最短的平均等待时间、平均周转时间")]),a._v(" "),v("li",[a._v("对于长作业不利")])]),a._v(" "),v("p",[a._v("会导致饥饿")]),a._v(" "),v("h5",{attrs:{id:"hrrn-高响应比优先"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#hrrn-高响应比优先"}},[a._v("#")]),a._v(" HRRN（高响应比优先）")]),a._v(" "),v("p",[a._v("综合考虑服务时间和等待时间")]),a._v(" "),v("p",[a._v("根据当前就绪队列的响应比进行选择，（等待时间+要求服务时间）/要求服务时间")]),a._v(" "),v("p",[a._v("一般为非抢占式")]),a._v(" "),v("p",[a._v("不会饥饿")]),a._v(" "),v("h4",{attrs:{id:"分时操作系统"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分时操作系统"}},[a._v("#")]),a._v(" 分时操作系统")]),a._v(" "),v("h5",{attrs:{id:"rr-时间片轮转"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#rr-时间片轮转"}},[a._v("#")]),a._v(" RR（时间片轮转）")]),a._v(" "),v("p",[a._v("对于进程，公平地和轮流的进行进程服务，这个是根据进程的状态变化和就绪队列的变化进行的，在进程用完一个时间片或是进程主动放弃才进行调度。")]),a._v(" "),v("p",[a._v("时间片的长短因系统和状态而不同")]),a._v(" "),v("p",[a._v("用于进程调度")]),a._v(" "),v("p",[a._v("抢占式 -- 通过时钟中断打断")]),a._v(" "),v("p",[a._v("时间片太大，就有可能变为FCFS，时间片太小，会导致进程切换过于频繁，时间片时间要合理")]),a._v(" "),v("p",[a._v("优点：公平 响应快 适合分时操作系统")]),a._v(" "),v("p",[a._v("缺点： 进程切换的时间开销")]),a._v(" "),v("p",[a._v("不会饥饿")]),a._v(" "),v("h5",{attrs:{id:"优先级调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优先级调度算法"}},[a._v("#")]),a._v(" 优先级调度算法")]),a._v(" "),v("p",[a._v("每个进程和作业都有自己的一个优先级别，当进程或作业完成时进行调度，按照优先级进行处理")]),a._v(" "),v("p",[a._v("可用于进程和作业调度")]),a._v(" "),v("p",[a._v("抢占和非抢占")]),a._v(" "),v("p",[a._v("会饥饿")]),a._v(" "),v("h5",{attrs:{id:"多级反馈队列调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多级反馈队列调度算法"}},[a._v("#")]),a._v(" 多级反馈队列调度算法")]),a._v(" "),v("p",[a._v("一般用于进程调度，抢占式")]),a._v(" "),v("p",[a._v("设置多个队列，每个队列的时间片和级别都有区分")]),a._v(" "),v("p",[a._v("会饥饿")]),a._v(" "),v("h2",{attrs:{id:"同步和互斥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步和互斥"}},[a._v("#")]),a._v(" 同步和互斥")]),a._v(" "),v("h3",{attrs:{id:"同步"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#同步"}},[a._v("#")]),a._v(" 同步")]),a._v(" "),v("p",[a._v("进程具有异步性，各自独立不可预知")]),a._v(" "),v("p",[a._v("进程同步就是让进程的执行符合我们给定的要求")]),a._v(" "),v("h3",{attrs:{id:"互斥"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#互斥"}},[a._v("#")]),a._v(" 互斥")]),a._v(" "),v("p",[a._v("资源的共享方式，对于可以互斥共享的临界资源")]),a._v(" "),v("p",[a._v("do{")]),a._v(" "),v("p",[a._v("进入区 -- 上锁")]),a._v(" "),v("p",[a._v("临界区 -- 访问资源")]),a._v(" "),v("p",[a._v("退出区-- 解锁")]),a._v(" "),v("p",[a._v("剩余区 -- 其余的处理")]),a._v(" "),v("p",[a._v("}while(1)")]),a._v(" "),v("p",[a._v("原则：")]),a._v(" "),v("ul",[v("li",[a._v("空闲让进入  -- 临界区空闲")]),a._v(" "),v("li",[a._v("忙则等待")]),a._v(" "),v("li",[a._v("有限等待 -- 保证不会饥饿")]),a._v(" "),v("li",[a._v("让权等待")])]),a._v(" "),v("h5",{attrs:{id:"实现方式-2"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现方式-2"}},[a._v("#")]),a._v(" 实现方式")]),a._v(" "),v("h6",{attrs:{id:"软件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#软件"}},[a._v("#")]),a._v(" 软件")]),a._v(" "),v("p",[a._v("单标志法\n思想两个进程在访问临界区后会把使用临界区的权限给另外一个")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("使用一个标志变量控制访问临界区的访问\n\n违背了空闲让进\n")])])]),v("p",[a._v("双标志先检查")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("设置一个bool数组，下标对应进程，值对应是否进入临界区\n\n由于异步性，可能存在两个进程同时进去临界区\n\n违背忙则等待\n")])])]),v("p",[a._v("双标志后检查")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("不同于上者，只是先把自己的标记为设置true上锁，在看其他的进程是否访问临界区\n\n违背了空闲让进，有限等待\n")])])]),v("p",[a._v("peterson算法")]),a._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",[v("code",[a._v("将双标志后检查和单标结合，通过单标达到主动让步的行为\n\n未遵循让权等待\n")])])]),v("h6",{attrs:{id:"硬件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#硬件"}},[a._v("#")]),a._v(" 硬件")]),a._v(" "),v("p",[a._v("中断屏蔽")]),a._v(" "),v("p",[a._v("适用内核进程的互斥实现")]),a._v(" "),v("p",[a._v("TestAndSet指令")]),a._v(" "),v("p",[a._v("使用TS指令上锁临界区，不会被中断打断，通过硬件实现标志")]),a._v(" "),v("p",[a._v("Swap指令")]),a._v(" "),v("h3",{attrs:{id:"信号量机制"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#信号量机制"}},[a._v("#")]),a._v(" 信号量机制")]),a._v(" "),v("p",[a._v("整形和记录型")])])}),[],!1,null,null,null);v.default=s.exports}}]);