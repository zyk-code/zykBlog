(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{479:function(n,t,v){"use strict";v.r(t);var _=v(2),a=Object(_.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("p",[n._v("定义题回归课本")]),n._v(" "),t("h2",{attrs:{id:"第一章"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第一章"}},[n._v("#")]),n._v(" 第一章")]),n._v(" "),t("p",[n._v("程序设计=数据结构+算法")]),n._v(" "),t("ol",[t("li",[t("p",[n._v("数据结构基本概念：\n（1）数据：对客观事物的符号表示，在计算机科学中的是指所有能输入到计算机中并被计算机程序处理的符号总称\n数据元素：数据的基本单位，由数据项组成\n数据项：最小单位不可分割\n数据对象：性质相同的数据元素的集合\n抽象数据类型（ADT）:一个数学模型以及定义在该模型上的一组操作 （抽象数据组织 + 与之相关的操作）\n只关注逻辑\n组成：数据对象 数据关系 基本操作集\n数据类型：一个值的集合+定义在这个集合的一组操作的总称\n作用：用来说明变量或表达式的取值范围、存储方式\n说明能进行的操作\n分类：原子类型 固定聚合类型 可变聚合类型（后面统称为结构类型）\n数据结构：相互之间存在一种或多种特定关系的数据元素的集合\n三要素：\n逻辑结构:抽象的\n存储结构:具体的\n数据运算\n（2）数据的逻辑结构：数据对象中的数据元素之间的相互关系，描述数据之间的逻辑关系\n关系（结构）：\n1.集合 2.线性结构 3.树形结构 4.图状结构或网状结构\n分类：线性结构（栈 队列 堆） 非线性结构\n数据的存储结构：逻辑结构的关系存储到计算机中\n数据域：数据元素由若干数据项构成，数据项就是数据域\n表示方法：顺序映像（顺序存储结构） 非顺序映像（链式存储结构）\n存储结构：顺序存储结构 链式存储结构（结构密度） 索引存储结构 散列存储结构（Hash）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v(" 注意：存储和存取（顺序和随机）不同，不等。\n")])])])])]),n._v(" "),t("p",[n._v("（3）数据的操作：")]),n._v(" "),t("p",[n._v("2．质算法和算法的时间复杂度：\n（1）算法的概念和性质\n指令：能被人和计算机执行\n算法概念：对特定问题求解步骤的一种描述，它是指令的有限序列\n算法性质：有穷性（程序不是一个算法） 确定性（指令正确） 可行性（操作可自行） 输入（0个或多个） 输出（至少一个）\n算法评价：正确性 可读性 健壮性 高效率和低存储量\n（2）算法的时间效率分析\n方法：事后统计法（复试上机用） 事前分析估计方法（初试必考）\n时间复杂度：\n语句频度（一个语句出现的次数）\n通过比值n->无穷大 取极限判断两个程序的时间 用增长最快o的比较\n数量级：保留最复杂的一项和它的系数（最内层）\nf(n)为频度之和 n是算法的规模 T（n）= O(f(n))  例子：f(n)=3*n^2+n 则 T(n)=O(n^2)\nT符合加法和乘法\n最坏时间复杂度 最好时间复杂度 平均时间复杂度\n空间复杂度：S（n） = O(g(n))\n原地工作O（1）并不是不占用内存\nmalloc的计算（看表达式） 原地（为1） 函数递归调用（一次调用可以看作一个单位的空间）\n计算方法：\n枚举法：列举归纳，根据递归的逻辑写T（n），非递归的看，控制变量，进行计数，再求计数总和（数列的求和公式）\n设t值法：设t次结束，建立与n的关系，最后用n表示t(注意：log2 n 的2有时候是默认的会不写)")]),n._v(" "),t("h2",{attrs:{id:"第二章-线性表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第二章-线性表"}},[n._v("#")]),n._v(" 第二章 线性表")]),n._v(" "),t("p",[n._v("**线性结构（一对一） **\n(非空线性表)特点：在数据元素的非空有限集合\n1.存在惟一的一个被称为第一个的数据元素\n​2.存在惟一的一个被称为最后一个的数据元素\n3.除了第一个之外，集合中的每个数据元素均只有一个前驱\n4.除最后一个之外，集合中每一个数据元素均只有一个后继\n**线性结构（**树、网、图、集合）")]),n._v(" "),t("h3",{attrs:{id:"线性表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线性表"}},[n._v("#")]),n._v(" 线性表：")]),n._v(" "),t("h4",{attrs:{id:"逻辑结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#逻辑结构"}},[n._v("#")]),n._v(" 逻辑结构：")]),n._v(" "),t("p",[t("strong",[n._v("定义")]),n._v("： 具有相同数据类型的n（N>=0 0为空表）个数据元素的有限序列\n"),t("strong",[n._v("判定")]),n._v("：一对一  同类型 有限 逻辑结构\n​"),t("strong",[n._v("表示")]),n._v("： L命名 L=(a1,a2...an)\n​"),t("strong",[n._v("线性表的长度")]),n._v("：表中含有的元素个数。可以为0\n​"),t("strong",[n._v("位序")]),n._v("：ai是第i个数据元素，称i为数据元素ai在线性表中的位序  数组小标是从0开始的，位序是从1开始的\n​"),t("strong",[n._v("顺序表")]),n._v("：采用顺序存储对线性表的表现，是指存储结构\n​"),t("strong",[n._v("链表："),t("strong",[n._v("采用链式存储对线性表的表现，是指存储结构\n​")]),n._v("​存储结构​")]),n._v("：\n1.顺序存储结构： 顺序表\n2.链式存储结构： 单链表 双链表 循环链表 静态链表 （前面三个是分开申请空间malloc 最后一个由数组实现）")]),n._v(" "),t("h4",{attrs:{id:"顺序表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#顺序表"}},[n._v("#")]),n._v(" 顺序表：")]),n._v(" "),t("p",[t("strong",[n._v("定义")]),n._v("：把线性表中所有元素按逻辑顺序，依次存储到从指定位置开始的一块连续存储空间\n"),t("strong",[n._v("特点")]),n._v("：第一个元素的存储位置就是指定的存储位置，第i+1个元素的存储位置紧接在第i个元素的存储位置后面")]),n._v(" "),t("p",[t("strong",[n._v("相对链表：")]),n._v("\n1、可以随机访问\n2、占用存储空间连续\n3、顺序表的插删，需要移动多个元素")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("实现​")]),n._v("：（数组或者动态数组）\n每+1就地址加多一个sizeof（类型） &L=a1 &L+sizeof()=a2\n结构体：\n静态分配特点：数空间组大小固定\n动态分配（动态分配不是链式存储）特点：动态分配，空间满了可以开辟一块更大的空间\n插入最后不需要移动元素（从后往前）、删除就是覆盖（从前向后）\n​"),t("strong",[n._v("时间复杂度分析​")]),n._v("：\n最好的情况：在表尾插入 O(1)\n平均情况：移动平均次数 n/2 o(n)")]),n._v(" "),t("h4",{attrs:{id:"链表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#链表"}},[n._v("#")]),n._v(" 链表：")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("定义​")]),n._v("：每个结点内容（所储存的元素和元素之间的逻辑关系信息（指针）），逻辑密度会小于1，顺序表的等于1\n​"),t("strong",[n._v("结点​")]),n._v("：指针域和数据域\n​"),t("strong",[n._v("相对线性表​")]),n._v("：\n1、线性表只能顺序访问（存取），链表可以随机\n2、占用额外的存储空间存储元素间关系，空间利用率更低\n3、存储空间不一定连续\n4、链表的插入不需要移动多个元素")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("分类标准​")]),n._v("：链表结点所包含的指针个数、指针指向和指针连接方式\n​"),t("strong",[n._v("分类​")]),n._v("：\n1、单链表 循环链表 双向链表（存储线性表）(越往后空间需求越)\n2、二叉链表 十字链表 邻接表 邻接多重表（存储非线性结构 树  图）\n​"),t("strong",[n._v("特点​")]),n._v("：\n1、解决了顺序表插删需要移动大量的元素的缺点\n2、引入指针域，浪费空间\n3、非随机存取，查找需要重头遍历。链表的最后一个结点的指针域（next）为NULL")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("头结点​")]),n._v("：链表第一个元素结点前附加的一个空结点\n​"),t("strong",[n._v("头结点的存在意义​")]),n._v("：使得链表在第一个位置上的操作和其他位置上的一样，空表和非空表统一处理  空表的偷头指针为空\n​"),t("strong",[n._v("静态链表​")]),n._v("：一个数组形式的结构体，每个结构体就是一个结点，通过下标进行操作.next是一个数组的下标，就是一个相对指针 称为游标 =-1为结尾\n借用数组实现的描述线性表的链式存储结构.它不允许扩容，需要一次性申请大量内存")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("基本操作​")]),n._v("：\n1.InintList(&L) -> 初始化列表\n2.Length(L) -> 返回线性表L的长度\n3.LocateElem(L,e) -> 按值查找操作，查找e值\n4.GetElem(L,i) -> 按位查找操作，查找i值\n5.ListInsert(&L,i,e) -> 插入操作，i位，e数值"),t("br"),n._v("\n6.ListDelete(&L,i,&e) -> 删除操作，并用e返回删除值\n7.PrintList(L) -> 输出操作（按前后顺序输出）\n8.Empty(L) -> 判空操作\n9.DestroyList(&L) -> 销毁操作（释放内存）")]),n._v(" "),t("p",[n._v("注意：这里引用（&是在c++中才有的），如果纯c是可以直接用指正*L\n1.当需要对传入本身修改时，可选择使用\n2.当数据本身比较时，为避免复制开销，可以使用")]),n._v(" "),t("h2",{attrs:{id:"第三章-栈和队"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第三章-栈和队"}},[n._v("#")]),n._v(" 第三章 栈和队")]),n._v(" "),t("h4",{attrs:{id:"栈"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#栈"}},[n._v("#")]),n._v(" 栈")]),n._v(" "),t("p",[n._v("​"),t("strong",[n._v("定义​")]),n._v("：限定在表尾（或者表头 就是一端）进行插入和删除的线性表 表头：栈底（bottom）  表尾：栈顶（top）栈底是固定的，是最先入栈的\n"),t("strong",[n._v("栈的插入")]),n._v("：入栈或压栈\n"),t("strong",[n._v("栈的删除")]),n._v(": 出栈或弹栈\n"),t("strong",[n._v("溢出")]),n._v("：上下溢\n"),t("strong",[n._v("栈空")]),n._v("：栈空的约定不是定的可以是-1 也可以是0；\n"),t("strong",[n._v("顺序")]),n._v("：后进先出，最先进去的不一定最后出去，不存在出栈顺序\n"),t("strong",[n._v("顺序存储方式")]),n._v("：\n1、顺序栈：数组实现\n2、共享栈：就是两个栈共享一个空间，分为左右两片空间，有top1 top2 不浪费maxsiz的空间\n"),t("strong",[n._v("链式存储方式")]),n._v("：\n1、链栈：单链表实现，栈空 NET->null  不存在栈满\n"),t("strong",[n._v("catalan函数")]),n._v("：\n对于堆栈，入栈n次和出栈n次后栈空 总的次数是2n次\n有C(2n,n)总方式，其中合法的是出栈的次数小于等于入栈的次数")]),n._v(" "),t("p",[n._v("（2n,-2） 就是出n+1 ,入n-1;\n不合法的次数为 c(2n,n-1)\n合法的就用 c(2n,n)-c(2n,n-1)=[1/(n+1)]*c(2n,n)")]),n._v(" "),t("h4",{attrs:{id:"队列"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#队列"}},[n._v("#")]),n._v(" 队列")]),n._v(" "),t("p",[t("strong",[n._v("定义")]),n._v("：先进先出的线性表（允许一端插入，一端删除的操作）\n入队（进队）：插入\n出队（离队）：删除\n"),t("strong",[n._v("循环队列")]),n._v("：就是形成一个环状，队尾和队头指针没有绝对的前后关系\n"),t("strong",[n._v("双端队列")]),n._v("：就是两端都可以插入和删除 分为前后端,受限的双端就是，某一端只能插入或者删除\n"),t("strong",[n._v("顺序的实现方式")]),n._v("：\n出队指针变化：(*Q).ftont=(*Q).ftont+1)%MaxSize\n入队指针变化：(*Q).rear=(*Q).rear+1)%MaxSize\n队长：rear在ftont的后面，就是rear -ftont      rear在ftont的前面  MaxSize-(ftont-rear)\n综合 MaxSize-(ftont-rear)%MaxSize\n方式一：牺牲一个元素区分队满队空（上）\n方式二：添加一个size 数据成员\n方式三：添加一个tag 数据成员 删除时候队伍空 0  插入导致队满 1\n"),t("strong",[n._v("链式的实现方式")]),n._v("：\n链队列：带有队头和队尾指针的链表  （就是在节点上有指针）\n不存在上溢出 ，适合多次插删")]),n._v(" "),t("h4",{attrs:{id:"应用"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#应用"}},[n._v("#")]),n._v(" 应用")]),n._v(" "),t("p",[t("strong",[n._v("栈")]),n._v("：\n1.括号匹配\n2.表达式的求值问题\n3.递归  函数栈，递归")]),n._v(" "),t("p",[t("strong",[n._v("队列")]),n._v("：\n1.树的层次遍历\n2.图的广度优先遍历\n3.FCFS（先来先服务，操作系统）")]),n._v(" "),t("h2",{attrs:{id:"第四章-串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第四章-串"}},[n._v("#")]),n._v(" 第四章 串")]),n._v(" "),t("p",[t("strong",[n._v("存储结构")]),n._v("：定长顺序表 堆分配 块链分配")]),n._v(" "),t("p",[t("strong",[n._v("朴树算法")]),n._v(": 时间复杂度O(n*m)\n"),t("strong",[n._v("kmp算法")]),n._v("：时间复杂度O(n+m)\n求next数组"),t("br"),n._v("\n串的前后缀 next[j]=S的最长相等前后缀长度（有的前后缀可以为0，就是一个符合）+1  特殊情况：第一个就饿匹配失败所以next[1]=0； next[2]=1\nnextvaul[] 数组\n避免了回溯")]),n._v(" "),t("h2",{attrs:{id:"第五章-数组和广义表"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第五章-数组和广义表"}},[n._v("#")]),n._v(" 第五章 数组和广义表")]),n._v(" "),t("p",[n._v("一维数组下标求绝对地址array[i]=array[0]+i*sizeof(类型)   就是数组在内存中的样子（很简单） 二维或者多维的理解是一样的 存储结构是顺序存储")]),n._v(" "),t("p",[n._v("二维或者多维的数组，要按行列（一行一行的按顺序存在内存）的优先存储在一片连续的空间内（还有列优先 是一列一列的按顺序存在内存）\n行优先（列优先）计算有绝对地址   本质就是求A(l1 l2)到A(ij)有多少个元素，不同的优先原则有不同的存放顺序")]),n._v(" "),t("h4",{attrs:{id:"矩阵的压缩存储"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#矩阵的压缩存储"}},[n._v("#")]),n._v(" 矩阵的压缩存储")]),n._v(" "),t("p",[n._v("矩阵注意下标，一般的矩形用二维数组存放")]),n._v(" "),t("p",[t("strong",[n._v("对称矩阵（方阵）")]),n._v("：可以存储主对角线和对角线上或者下的数据，我们需要存1+2+3+...+n个数据，可以用一维数组，可以用映射函数\n行优先  （i>=j）Aij是第几个元素->i（i-1）/2 + j 注意对应的数组下标要-1 （有的数组下标是从1开始可以不用减）j>=i）")]),n._v(" "),t("p",[t("strong",[n._v("三角矩阵")]),n._v("：（又一边元素相同）可以同上，变化\n（还有两种：核心观念就是找到对应数组的第几个和矩阵的下标的关系）\n"),t("strong",[n._v("稀疏矩阵")]),n._v("：（前面两种都是顺序存储    后面两种是链式存储）\n"),t("strong",[n._v("三元组")]),n._v(" ：  就是将ij和数值放到结构体数组或者n"),t("em",[n._v("3的数组中\n"),t("strong",[n._v("伪地址")]),n._v("： 就是用二维数组或者结构体数组存放k和数值（就是第k个被访问到的数e （k,e）） 能用k还原ij 也可由ij得到k\n从0开始 k=n")]),n._v("i+j  k/n=i k%n=j 从1开始 k=n*(i-1)+j  i-1=k-1/n j-1=k-1%n\n"),t("strong",[n._v("邻接表")]),n._v("：就是用一个一维数组存放链表，一个链表表示一行或者一列的连续的元素和对应的列或行标\n"),t("strong",[n._v("十字链表法")]),n._v(":\n一个结点要存：i j e 同行下一个（非0）和同列下一个指针"),t("br"),n._v("\n左上角为头结点（需要有行列数组指针 和总的行列数 整个矩阵的总数）")]),n._v(" "),t("p",[t("strong",[n._v("（王道没有） 广义表")]),n._v("：线性表的推广，表中的元素不局限是一个数据可以是一组数据 就是表中有表（递归） 多层次线性结构\n表的长度：表里有多少个元素 （1,2,3，（4,5），6）  表长就是4\n表的深度：表最里面的就是的那个括号在第几层 （1,2,3，（4,5），6）  表深就是2\n表头：就是第一个\n表尾：是除去表头的新的广义表（不同线性表）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    数组不好实现都是通过链式存储实现（链表）\n    存储结构：头尾链表存储结构和扩展广义表存储结构\n\n    头尾： p109图\n            原子结点：标记域（是原子0还是表1） 数据域  尾指针\n            广义表节点：标记域（是原子0还是表1） 头指针 尾指针域\n            尾指针指向的是表尾元素组成的新表\n            第一层有多少个结点就有多少个元素\n            \n    扩展：\n            原子结点：标记域（是原子0还是表1） 数据域  尾指针\n            广义表节点：标记域（是原子0还是表1） 头指针 尾指针域\n            原子结点尾指针指向的是同层次的下一个结点\n")])])]),t("h2",{attrs:{id:"第六章-树-递归"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#第六章-树-递归"}},[n._v("#")]),n._v(" 第六章 树（递归）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    树：根结点 分支结点 叶子结点 （每个结点有唯一前驱）  （逻辑结构）\n            空树：没有结点\n            子树：\n            度：一个结点下的子结点个数\n            树的度是结点中度最大的度\n            深度是从结点一直到根结点的长度（结点个数包括自己）\n            高度是从结点向下直到叶子结点的长度（结点个数包括自己）\n            双亲就是前驱结点\n            祖先就是从前驱开始一直往上直到根结点\n            路径长度\n            树的高度和深度是从根结点到叶子结点\n\n            m叉树和度为m的树区别\n            m叉树是每个结点的度为小于m 可为0 ，可以为空树\n            度为m的树是这个树中最大的度 不可为空树\n\n            性质考点：\n                    n个结点的树有n-1条边 \n\n                    结点数：\n                    结点数=总度数+1\n                    高度度为h的m叉树至多有m^h-1/m-1(等比数列求和)\n                    高度度为h的m叉树至少有 h个 高度h度为m的数h+m-1个结点\n                    度为m的树，第i层的上至多有m^h(i-1)个结点（i从1开始）\n                    n个结点的m叉树的最小高度logm(n(m-1)+1) 向上取整\n\n            顺序存储方式：\n                    双亲存储结构（结构体数组 里面有数据和双亲的指针（相对指针 （数组的下标）根结点的双亲下标是-1）\n                    孩子存储结构（数据域和孩子指针域（树的度为多少就设计多少个指针） 没用的为NULL  占用内存浪费）\n                    孩子兄弟存储结构（数据 和 孩子 和 兄弟）跟广义表有点像\n            链式存储方式：\n                    邻接表的形式存储（数组+链表（链表内存对应的孩子下标））\n                    数据域 + 左右指针 + （父亲指针）\n\n    二叉树：是n个结点的集合可为空\n            两个子树是分左右的不可颠倒（是有序树）（无序树是左右子树交换树不变的树）\n\n            斜树（线性表）：左右斜树 --\x3e线性表是一种特殊的树\n\n            特殊二叉树：\n                    1.满二叉树：高度h,结点数为2^h-1\n                            每一结点的度都为二\n                            只有最后一行是叶子结点\n                            按层序从1开始，结点i的左树为2i，右树为2i+1 可用i/2取整得到父节点\n                    \n                    2.完全的二叉树：就是可以在满二叉树的基础上去掉一些编号大（要连续）的树\n                            一个度为1的结点 这个结点只能在左\n                            i<=[n/2]为分支结点 i>[n/2]叶子结点 --\x3e [n/2] 是最后一个分支结点，后面都为叶子结点\n                            结点的度为0或为1就是i往后的结点都是叶子结点\n\n                    3.二叉排序树：左子树上的所有关键字都小于根结点的关键字 右子树上的所有关键字都大于根结点的关键字（左右子树也是二叉排序树）\n\n                    4.平衡二叉树：树上任意一结点的左右子树的深度差不超过1\n\n            性质考点：\n                    1. 度为0的结点n0（叶子结点）=度为2的结点n2+1 （由结点总数公式推导）\n\n                    2.i层结点至多2^i-1\n\n                    3.高度度为h的二叉树至多有 2^h-1\n\n                    4.n个结点的m叉树的最小高度log2（n+1）{同上推理}或者 log2（n） + 1 {完全二叉树的最后一行只有一个叶子结点}\n\n                    5.有n推出度为0 1 2 的结点个数 （分奇数偶数） \n\n            存储结构：      \n                    顺序存储方式：(数组)\n                            普通的二叉树按完全二叉树的结点编号方式进行\n                    链式存储方式：(二叉链表)\n                            数据域 + 左右指针 + （父亲指针）\n\n            二叉表的遍历：(递归和栈 实现) p根 l左子树 r右子树\n                    先序遍历：PLR \n                    中序遍历：LPR 非递归的实现时候，结束的条件是栈空且没有右子树\n                    后序遍历：LRP 非递归的实现时候，循环注意的是右子树\n                    (非递归 线索二叉树)\n                    层序遍历：从左到右 从上到下 按行遍历（用队列 根入队 访问根 根左右孩子入队）\n                    \n                    先中后是深度遍历\n                    层次是广度遍历\n\n                    手工遍历的方法很好用（截图）就是在每个结点标记123然后按树的形状描边，得到的对应标号的排序为对应的遍历方式\n\n                    反推是根据上面的lpr的位置重合把子树和根找出来 先中 中后 中层已知 可以反推出树的形状   已知先后不可反推\n")])])]),t("p",[n._v("​"),t("br"),n._v("\n​                线索二叉树\n​                        定义：利用空指针域（左右中一个)存某一种遍历方式下的前驱或后继（左指向前驱或头结点 右指向后继或头结点）\n​                        加快了查找直接前驱和后继的速度，让非递归遍历省去了一些栈\n​                        结点：lchild ltag data rtag rchild\n​                                tag是表示左右指针指向的对象是孩子还是前驱后继\n​                        线索：指向前驱后继的指针\n​                        分类可以按遍历的方式分（中序重要）\n​                        线索化\n​"),t("br"),n._v("\n手工画线索二叉树：先画遍历的序列，找空指针指向后继前驱（分左右）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    树和森林的转换 \n            前面的孩子（左）兄弟（兄弟）存储法  树转二叉：就是一个左指针指向自己的第一个孩子，右指针指向自己的兄弟（如果很多个兄弟就套娃在右边）\n            森林转二叉树 1.先把每一棵树转换为二叉树 2.把树归为其中一颗树下的一个孩子\n            反过来同理\n\n            树转二叉树的重要规律\n                    二叉树中无右孩子的结点数 = 原树中分支结点数 + 1（由转换的核心左孩子右兄弟）\n\n    树和森林的遍历\n            树的遍历\n                    只有先后序没有中序（因为无法确定中）\n                    手工法还是同二叉树，只是少了个2\n                    树的先序遍历顺序和转换的二叉树先序遍历的序列一样的\n                    树的后序遍历顺序和转换的二叉树中序遍历的序列一样的\n            \n            森林的遍历\n                    每颗树先序遍历然后把结果按树的顺序进行拼接\n                    后序同理\n\n                     森林的中序（书上是，叫法有不同）遍历顺序和转换的二叉树中序遍历的序列一样的\n    \n    树的应用\n            1.并查集（图也会有） 一个集合  text1\n            2.二叉排序树（BST定查插找） \n                    中序遍历的时候是一个有序的序列\n                    删除是比较复杂的 （考虑最近的树会不会受到影响）\n                    删除叶子结点 直接操作\n                    删除单分支结点   删除结点，孩子接替结点的位置\n                    删除双分支结点   找左边最右下的（就是左子树最大的结点 前驱）\n                                    找右边最左下的（就是右子树最小的结点 后继）\n                                    和直接前驱或者直接后继交换 在删除（前面两种情况）\n                    查找效率   （i层*层结点）/N\n                                最复杂o(n)(就是一边斜)\n                                左右子树的高度差不超过1（平衡二叉树） 平均的查找长度为O（log2 n）\n            3.平衡二叉树（AVL）\n                    就是在二叉排序树的基础上进行调平衡 text2\n                    插入为例子 就是保持平衡的关键是将根结点变换（注意变换后结点的大小关系和位置的变化）\n                    有四种插入的模型ll rr lr rl；\n                    前两个只是需要换一次根结点 ，后面的两个都需要换两次根结点，需要判断最小不平衡的子树（要计算权重）\n            4.赫夫曼树(wpl)\n                    就是根据最短权重路径编排的一种二叉树 所以他的最小路径是固定的，但是可以有很多的组合结果\n                    构建它的方法就是，在给出的结点中找出两个最先的结点最为兄弟结点，构建一个根结点为两个结点权重和的子树\n                    然后在选这些结点（根结点）最小和两个为子树，继续组合。直到全部结点用完\n\n                    赫夫曼编码就是根据给出的权重按构建赫夫曼树的方式，按照左子树为0，右子树为1，或者反过来。\n                    得到叶子上的符号的编码方式\n")])])]),t("p",[n._v("##第七章 图")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    概念：\n    p159\n            顶点 v   就像一个个结点\n            边 e     连接顶点的（有方向和无方向 图也可分为有无方向）\n                    <v,w>!=<w,v>有向边\n                    (v,w)=（w,v）无向边\n            路径：两顶点间的顶点序列\n            简单路径：顶点不重复出现的路径\n            回路：第一个顶点和最后一个顶点相同的环\n            简单回路：在回路到的基础上，中间的顶点不重复 \n            路径长度：路径上边的数目\n\n            连通图：无向图中\n            强连通图：有向图中\n\n\n    存储结构:\n            1.邻接矩阵      适合稠密图\n                    性质：邻接矩阵的n次方的结果的ij是顶点i到j长度为n的路径数目\n                    可以使用矩阵压缩的形式存放无向图的邻接矩阵（上三角对称矩阵）\n                    度的计算：\n                            无向图：某个顶点的度这个顶点对应邻接矩阵的i行或列的非0元素\n                            有向图：\n                                    出度 这个顶点对应邻接矩阵的i行的非0元素\n                                    入度 这个顶点对应邻接矩阵的i列的非0元素\n                                    度=出度+入度\n                    求度的时间复杂度：O（|v|）  \n\n\n            2.邻接图        适合稀疏图\n                    数组+链表\n\n            3.十字链表      只能存有向图\n\n            4.邻接多重表    只能存无向图 \n\n    基本操作： 增删改查\n            注意邻接表的操作，是否需要遍历所有顶点的链表（时间复杂度有区别）\n\n    图的遍历：（都需要有一个标识是否被访问过顶点的数组）\n            广度遍历（BFS）：辅助队列 \n            深度遍历（DFS）：栈和递归实现\n    \n    最小生成树：\n\n\n            如果不是连通图，那么每一个连通子图的生成树组成生成森林\n\n            Prim（普利姆）算法：（有点像哈夫曼树的构建）\n                    从一个顶点开始一直将和它相关的权值最小的顶点纳入树中，知道所有的顶点（从顶点出发）\n            Kruskal(克鲁斯卡尔)算法：\n                    选择权重最小的边，让两头的顶点连通，直到所有的顶点都链接（从边出发）\n\n    最短路径\n    （常考）\n            1.单源最短路径\n            2.每一对顶点间的最短路径\n\n                    1.BFS(无权图)\n                    1.迪杰斯拉特（带权图 无权图）：这个可以解决上面算法的缺陷  (考手算，数组)\n                            三个数组记录：\n                                    标记顶点是否找到最短路径 fina\n                                    最短路径的长度  dist\n                                    路径的前驱      path                                                               \n                            1、初始化\n                            2、在第一轮遍历第fina，找到确定的dist中的最小长度对应的顶点，让这顶点的fina值为真,并且检查这个顶点到其他顶点是否有更小的权重路径，并更新dist和path\n                               在第二轮在遍历，找还没确定最小路径的，重复第一轮的操作\n                            时间复杂度都是跟扫描顶点的时间消耗\n\n                            坑：带负值得这个算法是会失效的\n            \n                    2、Floyd算法（利用动态规划,把问题分解为各个阶段）(这个可以填上面那个坑)\n                            思想：1轮不允许中转，2轮可以中转一个......知道没了（n轮踢腿）\n                            v(k) k从-1开始直到结点数（n）-1\n                            每一次都是遍历A矩阵（路径）,每一轮都会刷新矩阵\n                            用矩阵表示路径和path\n\n                            空间复杂度o（n平方）\n                            时间复杂度o （n的三次方） 因为除了遍历矩阵外还需要重复n轮\n\n                            注意：寻找完整的路径信息是通过一步步的添加中间的点\n\n                            坑：权重回路（带负数）的图这个算法会失效的\n    \n    有向无环图（DAG）：（考过）不会重复出现相同的操作数     \n            局部整体思想，合并局部的相同部分\n    \n    拓扑排序：AOV网\n            用DAG图\n\n    关键路径：\n            AOE网：顶点是事件，有向边上的权值便是活动完成的开销 用边表示事件的网络\n                    只有一个入度为0的顶点，开始顶点（源点）\n                    只有一个出度为0的顶点，结束顶点\n                    两点间有很多的路径，其中最长的路径就是关键路径(最短时间)\n            \n            性质（常考）\n")])])]),t("p",[n._v("第八章"),t("br"),n._v("\n静态查找\n顺序查找 ：\n思想\n时间复杂度（n）")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("            折半查找：（高频）（二分查找）（有序的书序表）\n                    思想：从中间开始对比，把范围缩小（就像试管检查那个瓶子里有毒药）\n                    判定树常考\n                    查找判定树,很像平衡二叉树---\x3e特性（右子树的结点数-左子树的结点数=0或者1）\n                    时间复杂度（log2n）\n            \n            分块查找：（选择题）\n                    索引顺序查找\n                    思想：分成一个个的区间，建立索引表（最大关键字和存储区间范围）\n                    注意，ASL的计算\n\n    动态查找\n            B树（图片）\n                    1.除了根结点其他节点都至少有m/2向上取整的分叉，m叉树，每个结点的关键字要在m-1以内\n                    2.满足所有子树的高度相同（比平衡二叉树还有苛刻）\n\n            散列查找（哈希）\n                    散列表（哈希表）\n")])])]),t("p",[n._v("第九章 排序")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("    内部和外部排序\n    时空复杂度 稳定性\n\n    插入排序\n            使用折半查找优化，注意稳定性（有相同的值在其中）\n\n            时间复杂度O（n平方）\n            空间复杂度O(1)\n\n            稳定性\n            顺序表和链表都可\n    \n    希尔排序\n            把表按d=n/某个数 划分表格，各个子表进行排序\n            重复，直接到d为1（某个数是给定的，一般是/2）\n\n            空间复杂度O(1)\n            最坏时间复杂度O(n平方)(目前无法证明)\n            n在某个范围内可以是n的1.3次方\n            如果d=1就是插入排序\n\n            稳定性不太行\n            只能顺序表\n\n    冒泡排序（基于交换的排序）\n            就是遍历一遍只交换其中两个需要交换的关键字的位置\n            重复上面的操作，指导有序\n            这样每一次遍历就将其中小的往前冒\n            结束没有交换了就完成\n\n            空间复杂度O(1)\n            最坏时间复杂度O(n^2) 最好是o(n)\n            平均时间复杂度O(n^2)\n\n            注意每一次移动的次数，是在swap函数里面，一般是3次\n\n            稳定性\n\n            顺序表和链表都可\n\n    快速排序（基于交换的排序） 考的比较多\n            最好时间复杂度为O（nlog2n） o(n*递归的次数)  //用函数栈分析递归\n            最坏时间复杂度0（n平方）\n            就是不断的将表分为小于和大于某个数的两边\n            跟二叉树相似 递归的次数和树的高度\n            平均性能最优秀的方法\n            \n            不稳定的\n    \n    简单选择排序（选择排序）\n\n            思想：就是找到列表一个最小（最大），一次次的扫描，向前面换\n            空间复杂度O（1）\n            时间复杂度O（n平方）\n            不稳定的\n            链表和顺序表都可\n\n    堆排序\n            建堆，堆分为两类，跟完全二叉树的相关联 就是在顺序存储（层序遍历）\n                    关键是堆化，其实就是找出子中最大的或者最小和目标比较，是否满足堆的条件\n            排序:先中建堆，然后把堆顶的元素（可以是最大的，也可以是最小）和末端交换，并对剩余进行堆化，循环前面的；\n             时间复杂度（nlog2n）\n\n             堆的插入：先把元素放入堆底部，让他不断上升（类似建堆的操作，比较的父亲）\n             堆的删除：删除那个位置，用堆底元素，然后让他下坠\n             注意：对比次数，（儿子中选择最大，在和父亲比），儿子只有一个就不用选\n\n             不稳定\n\n    归并排序（merge）\n\n            多个有序，合并成一个\n            归并的东西越多，比较的次数也就越多\n\n            把一个序列看成各个小的子表，利用二路归并\n\n            实现：用一个动态的辅助数组（会占用空间）\n            递归，用树理解\n\n            空间复杂度O（n）\n            时间复杂度（nlog2n）\n\n            稳定\n\n    基数排序：（没有关键字比较）\n            就是按位，进行收集，重复，直到最后一位\n            稳定\n\n\n\n    外部排序（上面的都是内部排序）\n            数据在硬盘是按块进行存储，也是按块读写，可用归并排序进行排序\n            时间开销还有读写内存的时间+内部排序+内部归并的时间\n            主要的影响是来自读写\n")])])]),t("p",[n._v("MOD -- 取余")])])}),[],!1,null,null,null);t.default=a.exports}}]);